/*
    This file is part of CrabEmu.

    Copyright (C) 2009, 2012, 2015 Lawrence Sebald

    CrabEmu is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License version 2 
    as published by the Free Software Foundation.

    CrabEmu is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with CrabEmu; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "cheats.h"
#include "smsmem.h"


int sms_cheats_enabled = 0;
static int sms_cheats_initted = 0;
static int count = 0;

TAILQ_HEAD(cheat_queue, smscheat_s) sms_cheats;

extern uint8 *sms_write_map[256];
extern int sms_bios_active;

int sms_cheat_init(void) {
    if(sms_cheats_initted)
        return 0;

    TAILQ_INIT(&sms_cheats);
    sms_cheats_initted = 1;
    return 0;
}

void sms_cheat_shutdown(void) {
    sms_cheat_reset();
    sms_cheats_initted = 0;
}

void sms_cheat_reset(void) {
    sms_cheat_t *i, *next;

    if(!sms_cheats_initted)
        return;

    i = TAILQ_FIRST(&sms_cheats);
    while(i) {
        next = TAILQ_NEXT(i, qentry);
        TAILQ_REMOVE(&sms_cheats, i, qentry);
        free(i);
        i = next;
    }

    sms_cheats_enabled = 0;
    count = 0;
}

void sms_cheat_frame(void) {
    sms_cheat_t *i;
    uint16 addr;
    uint8 data;

    if(!sms_cheats_enabled)
        return;

    /* If we're executing the bios, don't try to do cheat codes. This isn't
       exactly the safest way to do this, but hopefully it won't break too
       badly... */
    if(sms_bios_active)
        return;

    TAILQ_FOREACH(i, &sms_cheats, qentry) {
        if(i->enabled){
            addr = (uint16)(i->ar_code >> 8);
            data = (uint8)i->ar_code;

            sms_write_map[addr >> 8][(uint8)addr] = data;
        }
    }
}

int sms_cheat_add(sms_cheat_t *c) {
    TAILQ_INSERT_TAIL(&sms_cheats, c, qentry);
    ++count;
    return 0;
}

int sms_cheat_remove(int index) {
    sms_cheat_t *i;

    TAILQ_FOREACH(i, &sms_cheats, qentry) {
        if(!index--) {
            TAILQ_REMOVE(&sms_cheats, i, qentry);
            free(i);
            --count;
            return 0;
        }
    }

    return -1;
}

int sms_cheat_count(void) {
    return count;
}

sms_cheat_t *sms_cheat_get(int index) {
    sms_cheat_t *i;

    TAILQ_FOREACH(i, &sms_cheats, qentry) {
        if(!index--)
            return i;
    }

    return NULL;
}

int sms_cheat_read(const char *fn) {
    FILE *fp;
    char linebuf[256], str[64];
    size_t len;
    sms_cheat_t *c;
    unsigned int code1, code2;

    fp = fopen(fn, "r");
    if(!fp)
        return -1;

    while(fgets(linebuf, 256, fp)) {
        /* Ignore shell-style comments. */
        if(linebuf[0] == '#')
            continue;

        len = strlen(linebuf);

        /* Remove any line endings/whitespace at end. */
        while(isspace(linebuf[len - 1])) {
            linebuf[--len] = 0;
        }

        /* If the line is now blank, ignore it. */
        if(len == 0)
            continue;

        if(linebuf[0] != '0' || linebuf[1] != '0') {
            fprintf(stderr, "sms_cheat_read: Invalid line: %s\n", linebuf);
            continue;
        }

        /* Read the code from the line. */
        sscanf(linebuf, "%4x-%4x", &code1, &code2);
        strncpy(str, linebuf + 10, 63);
        str[63] = 0;

        c = (sms_cheat_t *)malloc(sizeof(sms_cheat_t));
        c->ar_code = (code1 << 16) | code2;
        strcpy(c->desc, str);
        c->enabled = 1;

        sms_cheat_add(c);
    }

    fclose(fp);

    return 0;
}

int sms_cheat_write(const char *fn) {
    FILE *fp;
    sms_cheat_t *i;

    if(!sms_cheats_initted || TAILQ_EMPTY(&sms_cheats))
        return 0;

    fp = fopen(fn, "w");
    if(!fp)
        return -1;

    fprintf(fp, "# Cheats file generated by CrabEmu\n");

    TAILQ_FOREACH(i, &sms_cheats, qentry) {
        fprintf(fp, "%04X-%04X %s\n", (uint16)(i->ar_code >> 16),
                (uint16)i->ar_code, i->desc);
    }

    fclose(fp);

    return 0;
}

void sms_cheat_enable(void) {
    sms_cheats_enabled = 1;
}

void sms_cheat_disable(void) {
    sms_cheats_enabled = 0;
}
